/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthenticationClient {
    login(request: AuthenticateUserCommand): Observable<UserIdentity>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthenticationClient implements IAuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    login(request: AuthenticateUserCommand): Observable<UserIdentity> {
        let url_ = this.baseUrl + "/api/Authentication/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<UserIdentity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserIdentity>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<UserIdentity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserIdentity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserIdentity>(<any>null);
    }
}

export interface IFacultiesClient {
    get(): Observable<FacultiesVm>;
}

@Injectable({
    providedIn: 'root'
})
export class FacultiesClient implements IFacultiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<FacultiesVm> {
        let url_ = this.baseUrl + "/api/Faculties";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FacultiesVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacultiesVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FacultiesVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacultiesVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacultiesVm>(<any>null);
    }
}

export interface IGraduationPaperClient {
    get(request: GetGraduationPapersQuery): Observable<GraduationPapersVm>;
    getPaper(): Observable<GraduationPaperDto2>;
}

@Injectable({
    providedIn: 'root'
})
export class GraduationPaperClient implements IGraduationPaperClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: GetGraduationPapersQuery): Observable<GraduationPapersVm> {
        let url_ = this.baseUrl + "/api/GraduationPaper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GraduationPapersVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<GraduationPapersVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GraduationPapersVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraduationPapersVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GraduationPapersVm>(<any>null);
    }

    getPaper(): Observable<GraduationPaperDto2> {
        let url_ = this.baseUrl + "/api/GraduationPaper";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaper(<any>response_);
                } catch (e) {
                    return <Observable<GraduationPaperDto2>><any>_observableThrow(e);
                }
            } else
                return <Observable<GraduationPaperDto2>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaper(response: HttpResponseBase): Observable<GraduationPaperDto2> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraduationPaperDto2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GraduationPaperDto2>(<any>null);
    }
}

export interface IHomeClient {
    getProfile(): Observable<ProfileVm>;
    getNews(): Observable<NewsVm>;
}

@Injectable({
    providedIn: 'root'
})
export class HomeClient implements IHomeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getProfile(): Observable<ProfileVm> {
        let url_ = this.baseUrl + "/api/Home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(<any>response_);
                } catch (e) {
                    return <Observable<ProfileVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<ProfileVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileVm>(<any>null);
    }

    getNews(): Observable<NewsVm> {
        let url_ = this.baseUrl + "/api/Home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNews(<any>response_);
                } catch (e) {
                    return <Observable<NewsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<NewsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetNews(response: HttpResponseBase): Observable<NewsVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewsVm>(<any>null);
    }
}

export interface IStepsClient {
    notifyStudent(id: number, request: NotifyStudentCommand): Observable<FileResponse>;
    notifySupervisor(id: number, request: NotifySupervisorCommand): Observable<FileResponse>;
    getSteps(id: number): Observable<StepsVm>;
    getStep(id: number, stepId: number): Observable<StepDto2>;
    uploadAttachment(id: number, stepId: number, request: UploadAttachmentCommand): Observable<number>;
    updateStep(stepId: number, request: UpdateStepCommand): Observable<FileResponse>;
    approveStep(id: number, stepId: number, request: ApproveStepCommand): Observable<FileResponse>;
    rejectStep(id: number, stepId: number, request: RejectStepCommand): Observable<FileResponse>;
    finishStep(id: number, stepId: number, request: FinishStepCommand): Observable<FileResponse>;
    getAvailableSupervisors(): Observable<SupervisorsVm>;
    sendToReview(id: number, stepId: number, request: SendStepToReviewCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class StepsClient implements IStepsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    notifyStudent(id: number, request: NotifyStudentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Steps/NotifyStudent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotifyStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotifyStudent(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processNotifyStudent(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    notifySupervisor(id: number, request: NotifySupervisorCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Steps/NotifySupervisor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotifySupervisor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotifySupervisor(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processNotifySupervisor(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSteps(id: number): Observable<StepsVm> {
        let url_ = this.baseUrl + "/api/Steps/{id}/Steps";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSteps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSteps(<any>response_);
                } catch (e) {
                    return <Observable<StepsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StepsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetSteps(response: HttpResponseBase): Observable<StepsVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StepsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StepsVm>(<any>null);
    }

    getStep(id: number, stepId: number): Observable<StepDto2> {
        let url_ = this.baseUrl + "/api/Steps/{id}/Step/{stepId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStep(<any>response_);
                } catch (e) {
                    return <Observable<StepDto2>><any>_observableThrow(e);
                }
            } else
                return <Observable<StepDto2>><any>_observableThrow(response_);
        }));
    }

    protected processGetStep(response: HttpResponseBase): Observable<StepDto2> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StepDto2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StepDto2>(<any>null);
    }

    uploadAttachment(id: number, stepId: number, request: UploadAttachmentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Steps/{id}/Step/{stepId}/Attachment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAttachment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUploadAttachment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateStep(stepId: number, request: UpdateStepCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Steps/Step/{stepId}/Update";
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStep(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStep(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    approveStep(id: number, stepId: number, request: ApproveStepCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Steps/{id}/Step/{stepId}/Approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveStep(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApproveStep(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    rejectStep(id: number, stepId: number, request: RejectStepCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Steps/{id}/Step/{stepId}/Reject";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectStep(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRejectStep(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    finishStep(id: number, stepId: number, request: FinishStepCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Steps/{id}/Step/{stepId}/Finish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishStep(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFinishStep(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getAvailableSupervisors(): Observable<SupervisorsVm> {
        let url_ = this.baseUrl + "/api/Steps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableSupervisors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableSupervisors(<any>response_);
                } catch (e) {
                    return <Observable<SupervisorsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<SupervisorsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailableSupervisors(response: HttpResponseBase): Observable<SupervisorsVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupervisorsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupervisorsVm>(<any>null);
    }

    sendToReview(id: number, stepId: number, request: SendStepToReviewCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Steps/{id}/Step/{stepId}/ToReview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendToReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendToReview(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSendToReview(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IStudentsClient {
    create(command: CreateStudentCommand): Observable<number>;
    get(): Observable<StudentsVm>;
}

@Injectable({
    providedIn: 'root'
})
export class StudentsClient implements IStudentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateStudentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Students";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get(): Observable<StudentsVm> {
        let url_ = this.baseUrl + "/api/Students";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<StudentsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StudentsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StudentsVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentsVm>(<any>null);
    }
}

export interface ISupervisorsClient {
    getProfile(id: number, request: GetSupervisorQuery): Observable<SupervisorDto>;
    create(request: CreateSupervisorCommand): Observable<number>;
    addTopic(id: number, request: CreateTopicCommand): Observable<number>;
    updateTopic(id: number, topicId: number, request: UpdateTopicCommand): Observable<FileResponse>;
    deleteTopic(id: number, topicId: number, request: DeleteTopicCommand): Observable<FileResponse>;
    addField(id: number, request: CreateFieldCommand): Observable<number>;
    updateField(id: number, fieldId: number, request: UpdateFieldCommand): Observable<FileResponse>;
    deleteField(id: number, fieldId: number, request: DeleteFieldCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class SupervisorsClient implements ISupervisorsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getProfile(id: number, request: GetSupervisorQuery): Observable<SupervisorDto> {
        let url_ = this.baseUrl + "/api/Supervisors/{id}/Profile";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(<any>response_);
                } catch (e) {
                    return <Observable<SupervisorDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SupervisorDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<SupervisorDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupervisorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupervisorDto>(<any>null);
    }

    create(request: CreateSupervisorCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Supervisors/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    addTopic(id: number, request: CreateTopicCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Supervisors/{id}/AddTopic";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTopic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTopic(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddTopic(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateTopic(id: number, topicId: number, request: UpdateTopicCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Supervisors/{id}/UpdateTopic/{topicId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (topicId === undefined || topicId === null)
            throw new Error("The parameter 'topicId' must be defined.");
        url_ = url_.replace("{topicId}", encodeURIComponent("" + topicId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTopic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTopic(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTopic(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteTopic(id: number, topicId: number, request: DeleteTopicCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Supervisors/{id}/DeleteTopic/{topicId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (topicId === undefined || topicId === null)
            throw new Error("The parameter 'topicId' must be defined.");
        url_ = url_.replace("{topicId}", encodeURIComponent("" + topicId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTopic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTopic(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTopic(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    addField(id: number, request: CreateFieldCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Supervisors/{id}/AddField";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddField(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddField(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateField(id: number, fieldId: number, request: UpdateFieldCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Supervisors/{id}/UpdateField/{fieldId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateField(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateField(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteField(id: number, fieldId: number, request: DeleteFieldCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Supervisors/{id}/DeleteField/{fieldId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteField(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteField(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IUsersClient {
    lock(id: number, command: LockUserCommand): Observable<FileResponse>;
    unlock(id: number, command: UnlockUserCommand): Observable<FileResponse>;
    sync(): Observable<number>;
    create(): Observable<FileResponse>;
    get(): Observable<UsersVm>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    lock(id: number, command: LockUserCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/lock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLock(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLock(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    unlock(id: number, command: UnlockUserCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/unlock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlock(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUnlock(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    sync(): Observable<number> {
        let url_ = this.baseUrl + "/api/Users/sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    create(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    get(): Observable<UsersVm> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UsersVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsersVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UsersVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsersVm>(<any>null);
    }
}

export class UserIdentity implements IUserIdentity {
    token?: string | undefined;

    constructor(data?: IUserIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new UserIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface IUserIdentity {
    token?: string | undefined;
}

export class AuthenticateUserCommand implements IAuthenticateUserCommand {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAuthenticateUserCommand {
    username?: string | undefined;
    password?: string | undefined;
}

export class FacultiesVm implements IFacultiesVm {
    faculties?: FacultyDto[] | undefined;

    constructor(data?: IFacultiesVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["faculties"])) {
                this.faculties = [] as any;
                for (let item of _data["faculties"])
                    this.faculties!.push(FacultyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FacultiesVm {
        data = typeof data === 'object' ? data : {};
        let result = new FacultiesVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.faculties)) {
            data["faculties"] = [];
            for (let item of this.faculties)
                data["faculties"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFacultiesVm {
    faculties?: FacultyDto[] | undefined;
}

export class FacultyDto implements IFacultyDto {
    id?: number;
    externalId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
    shortTitle_EN?: string | undefined;
    shortTitle_LV?: string | undefined;
    shortTitle_RU?: string | undefined;
    programes?: ProgrameDto[] | undefined;

    constructor(data?: IFacultyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.title_RU = _data["title_RU"];
            this.title_EN = _data["title_EN"];
            this.title_LV = _data["title_LV"];
            this.shortTitle_EN = _data["shortTitle_EN"];
            this.shortTitle_LV = _data["shortTitle_LV"];
            this.shortTitle_RU = _data["shortTitle_RU"];
            if (Array.isArray(_data["programes"])) {
                this.programes = [] as any;
                for (let item of _data["programes"])
                    this.programes!.push(ProgrameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FacultyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacultyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["title_RU"] = this.title_RU;
        data["title_EN"] = this.title_EN;
        data["title_LV"] = this.title_LV;
        data["shortTitle_EN"] = this.shortTitle_EN;
        data["shortTitle_LV"] = this.shortTitle_LV;
        data["shortTitle_RU"] = this.shortTitle_RU;
        if (Array.isArray(this.programes)) {
            data["programes"] = [];
            for (let item of this.programes)
                data["programes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFacultyDto {
    id?: number;
    externalId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
    shortTitle_EN?: string | undefined;
    shortTitle_LV?: string | undefined;
    shortTitle_RU?: string | undefined;
    programes?: ProgrameDto[] | undefined;
}

export class ProgrameDto implements IProgrameDto {
    id?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;

    constructor(data?: IProgrameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title_RU = _data["title_RU"];
            this.title_EN = _data["title_EN"];
            this.title_LV = _data["title_LV"];
        }
    }

    static fromJS(data: any): ProgrameDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgrameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title_RU"] = this.title_RU;
        data["title_EN"] = this.title_EN;
        data["title_LV"] = this.title_LV;
        return data; 
    }
}

export interface IProgrameDto {
    id?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
}

export class GraduationPapersVm implements IGraduationPapersVm {
    paperStatuses?: PaperStatusDto[] | undefined;
    paperTypes?: PaperTypeDto[] | undefined;
    graduationPapers?: GraduationPaperDto[] | undefined;
    total?: number;

    constructor(data?: IGraduationPapersVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paperStatuses"])) {
                this.paperStatuses = [] as any;
                for (let item of _data["paperStatuses"])
                    this.paperStatuses!.push(PaperStatusDto.fromJS(item));
            }
            if (Array.isArray(_data["paperTypes"])) {
                this.paperTypes = [] as any;
                for (let item of _data["paperTypes"])
                    this.paperTypes!.push(PaperTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["graduationPapers"])) {
                this.graduationPapers = [] as any;
                for (let item of _data["graduationPapers"])
                    this.graduationPapers!.push(GraduationPaperDto.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): GraduationPapersVm {
        data = typeof data === 'object' ? data : {};
        let result = new GraduationPapersVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paperStatuses)) {
            data["paperStatuses"] = [];
            for (let item of this.paperStatuses)
                data["paperStatuses"].push(item.toJSON());
        }
        if (Array.isArray(this.paperTypes)) {
            data["paperTypes"] = [];
            for (let item of this.paperTypes)
                data["paperTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.graduationPapers)) {
            data["graduationPapers"] = [];
            for (let item of this.graduationPapers)
                data["graduationPapers"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IGraduationPapersVm {
    paperStatuses?: PaperStatusDto[] | undefined;
    paperTypes?: PaperTypeDto[] | undefined;
    graduationPapers?: GraduationPaperDto[] | undefined;
    total?: number;
}

export class PaperStatusDto implements IPaperStatusDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPaperStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PaperStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaperStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPaperStatusDto {
    value?: number;
    name?: string | undefined;
}

export class PaperTypeDto implements IPaperTypeDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPaperTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PaperTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaperTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPaperTypeDto {
    value?: number;
    name?: string | undefined;
}

export class GraduationPaperDto implements IGraduationPaperDto {
    id?: number;
    title?: string | undefined;
    supervisor?: string | undefined;
    student?: string | undefined;
    paperStatus?: number;
    paperType?: number;

    constructor(data?: IGraduationPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.supervisor = _data["supervisor"];
            this.student = _data["student"];
            this.paperStatus = _data["paperStatus"];
            this.paperType = _data["paperType"];
        }
    }

    static fromJS(data: any): GraduationPaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new GraduationPaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["supervisor"] = this.supervisor;
        data["student"] = this.student;
        data["paperStatus"] = this.paperStatus;
        data["paperType"] = this.paperType;
        return data; 
    }
}

export interface IGraduationPaperDto {
    id?: number;
    title?: string | undefined;
    supervisor?: string | undefined;
    student?: string | undefined;
    paperStatus?: number;
    paperType?: number;
}

export class GetGraduationPapersQuery implements IGetGraduationPapersQuery {
    skip?: number;
    take?: number;

    constructor(data?: IGetGraduationPapersQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): GetGraduationPapersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetGraduationPapersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IGetGraduationPapersQuery {
    skip?: number;
    take?: number;
}

export class GraduationPaperDto2 implements IGraduationPaperDto2 {
    id?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
    supervisor?: string | undefined;

    constructor(data?: IGraduationPaperDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title_RU = _data["title_RU"];
            this.title_EN = _data["title_EN"];
            this.title_LV = _data["title_LV"];
            this.supervisor = _data["supervisor"];
        }
    }

    static fromJS(data: any): GraduationPaperDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new GraduationPaperDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title_RU"] = this.title_RU;
        data["title_EN"] = this.title_EN;
        data["title_LV"] = this.title_LV;
        data["supervisor"] = this.supervisor;
        return data; 
    }
}

export interface IGraduationPaperDto2 {
    id?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
    supervisor?: string | undefined;
}

export class ProfileVm implements IProfileVm {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emails?: string[] | undefined;
    phoneNumbers?: string[] | undefined;
    faculty?: string | undefined;
    programe?: string | undefined;

    constructor(data?: IProfileVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(item);
            }
            this.faculty = _data["faculty"];
            this.programe = _data["programe"];
        }
    }

    static fromJS(data: any): ProfileVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item);
        }
        data["faculty"] = this.faculty;
        data["programe"] = this.programe;
        return data; 
    }
}

export interface IProfileVm {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emails?: string[] | undefined;
    phoneNumbers?: string[] | undefined;
    faculty?: string | undefined;
    programe?: string | undefined;
}

export class NewsVm implements INewsVm {

    constructor(data?: INewsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): NewsVm {
        data = typeof data === 'object' ? data : {};
        let result = new NewsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface INewsVm {
}

export class NotifyStudentCommand implements INotifyStudentCommand {
    graduationPaperId?: number;
    stepId?: number;

    constructor(data?: INotifyStudentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.graduationPaperId = _data["graduationPaperId"];
            this.stepId = _data["stepId"];
        }
    }

    static fromJS(data: any): NotifyStudentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new NotifyStudentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["graduationPaperId"] = this.graduationPaperId;
        data["stepId"] = this.stepId;
        return data; 
    }
}

export interface INotifyStudentCommand {
    graduationPaperId?: number;
    stepId?: number;
}

export class NotifySupervisorCommand implements INotifySupervisorCommand {
    graduationPaperId?: number;
    stepId?: number;

    constructor(data?: INotifySupervisorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.graduationPaperId = _data["graduationPaperId"];
            this.stepId = _data["stepId"];
        }
    }

    static fromJS(data: any): NotifySupervisorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new NotifySupervisorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["graduationPaperId"] = this.graduationPaperId;
        data["stepId"] = this.stepId;
        return data; 
    }
}

export interface INotifySupervisorCommand {
    graduationPaperId?: number;
    stepId?: number;
}

export class StepsVm implements IStepsVm {
    statuses?: StepStatusDto[] | undefined;
    types?: StepTypeDto[] | undefined;
    steps?: StepDto[] | undefined;
    graduationPaper?: GraduationPaperDto3 | undefined;

    constructor(data?: IStepsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StepStatusDto.fromJS(item));
            }
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(StepTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(StepDto.fromJS(item));
            }
            this.graduationPaper = _data["graduationPaper"] ? GraduationPaperDto3.fromJS(_data["graduationPaper"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StepsVm {
        data = typeof data === 'object' ? data : {};
        let result = new StepsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item.toJSON());
        }
        data["graduationPaper"] = this.graduationPaper ? this.graduationPaper.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStepsVm {
    statuses?: StepStatusDto[] | undefined;
    types?: StepTypeDto[] | undefined;
    steps?: StepDto[] | undefined;
    graduationPaper?: GraduationPaperDto3 | undefined;
}

export class StepStatusDto implements IStepStatusDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IStepStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): StepStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new StepStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStepStatusDto {
    value?: number;
    name?: string | undefined;
}

export class StepTypeDto implements IStepTypeDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IStepTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): StepTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new StepTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStepTypeDto {
    value?: number;
    name?: string | undefined;
}

export class StepDto implements IStepDto {
    id?: number;
    stepType?: number;
    stepStatus?: number;

    constructor(data?: IStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stepType = _data["stepType"];
            this.stepStatus = _data["stepStatus"];
        }
    }

    static fromJS(data: any): StepDto {
        data = typeof data === 'object' ? data : {};
        let result = new StepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stepType"] = this.stepType;
        data["stepStatus"] = this.stepStatus;
        return data; 
    }
}

export interface IStepDto {
    id?: number;
    stepType?: number;
    stepStatus?: number;
}

export class GraduationPaperDto3 implements IGraduationPaperDto3 {
    title?: string | undefined;
    student?: string | undefined;
    supervisor?: string | undefined;
    supervisorId?: number;
    year?: number;

    constructor(data?: IGraduationPaperDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.student = _data["student"];
            this.supervisor = _data["supervisor"];
            this.supervisorId = _data["supervisorId"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): GraduationPaperDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new GraduationPaperDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["student"] = this.student;
        data["supervisor"] = this.supervisor;
        data["supervisorId"] = this.supervisorId;
        data["year"] = this.year;
        return data; 
    }
}

export interface IGraduationPaperDto3 {
    title?: string | undefined;
    student?: string | undefined;
    supervisor?: string | undefined;
    supervisorId?: number;
    year?: number;
}

export class StepDto2 implements IStepDto2 {
    id?: number;
    stepType?: number;
    stepStatus?: number;
    data?: string | undefined;
    attachments?: AttachmentDto[] | undefined;

    constructor(data?: IStepDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stepType = _data["stepType"];
            this.stepStatus = _data["stepStatus"];
            this.data = _data["data"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StepDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new StepDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stepType"] = this.stepType;
        data["stepStatus"] = this.stepStatus;
        data["data"] = this.data;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStepDto2 {
    id?: number;
    stepType?: number;
    stepStatus?: number;
    data?: string | undefined;
    attachments?: AttachmentDto[] | undefined;
}

export class AttachmentDto implements IAttachmentDto {
    id?: number;
    name?: string | undefined;
    data?: string | undefined;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["data"] = this.data;
        return data; 
    }
}

export interface IAttachmentDto {
    id?: number;
    name?: string | undefined;
    data?: string | undefined;
}

export class UploadAttachmentCommand implements IUploadAttachmentCommand {
    graduationPaperId?: number;
    stepId?: number;
    name?: string | undefined;
    data?: string | undefined;

    constructor(data?: IUploadAttachmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.graduationPaperId = _data["graduationPaperId"];
            this.stepId = _data["stepId"];
            this.name = _data["name"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): UploadAttachmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UploadAttachmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["graduationPaperId"] = this.graduationPaperId;
        data["stepId"] = this.stepId;
        data["name"] = this.name;
        data["data"] = this.data;
        return data; 
    }
}

export interface IUploadAttachmentCommand {
    graduationPaperId?: number;
    stepId?: number;
    name?: string | undefined;
    data?: string | undefined;
}

export class UpdateStepCommand implements IUpdateStepCommand {
    graduationPaperId?: number;
    stepId?: number;
    data?: string | undefined;

    constructor(data?: IUpdateStepCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.graduationPaperId = _data["graduationPaperId"];
            this.stepId = _data["stepId"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): UpdateStepCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStepCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["graduationPaperId"] = this.graduationPaperId;
        data["stepId"] = this.stepId;
        data["data"] = this.data;
        return data; 
    }
}

export interface IUpdateStepCommand {
    graduationPaperId?: number;
    stepId?: number;
    data?: string | undefined;
}

export class ApproveStepCommand implements IApproveStepCommand {
    graduationPaperId?: number;
    stepId?: number;
    supervisorId?: number;

    constructor(data?: IApproveStepCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.graduationPaperId = _data["graduationPaperId"];
            this.stepId = _data["stepId"];
            this.supervisorId = _data["supervisorId"];
        }
    }

    static fromJS(data: any): ApproveStepCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveStepCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["graduationPaperId"] = this.graduationPaperId;
        data["stepId"] = this.stepId;
        data["supervisorId"] = this.supervisorId;
        return data; 
    }
}

export interface IApproveStepCommand {
    graduationPaperId?: number;
    stepId?: number;
    supervisorId?: number;
}

export class RejectStepCommand implements IRejectStepCommand {
    stepId?: number;
    graduationPaperId?: number;
    reason?: string | undefined;
    deassignSupervisor?: boolean;

    constructor(data?: IRejectStepCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepId = _data["stepId"];
            this.graduationPaperId = _data["graduationPaperId"];
            this.reason = _data["reason"];
            this.deassignSupervisor = _data["deassignSupervisor"];
        }
    }

    static fromJS(data: any): RejectStepCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RejectStepCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepId"] = this.stepId;
        data["graduationPaperId"] = this.graduationPaperId;
        data["reason"] = this.reason;
        data["deassignSupervisor"] = this.deassignSupervisor;
        return data; 
    }
}

export interface IRejectStepCommand {
    stepId?: number;
    graduationPaperId?: number;
    reason?: string | undefined;
    deassignSupervisor?: boolean;
}

export class FinishStepCommand implements IFinishStepCommand {
    graduationPaperId?: number;
    stepId?: number;

    constructor(data?: IFinishStepCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.graduationPaperId = _data["graduationPaperId"];
            this.stepId = _data["stepId"];
        }
    }

    static fromJS(data: any): FinishStepCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FinishStepCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["graduationPaperId"] = this.graduationPaperId;
        data["stepId"] = this.stepId;
        return data; 
    }
}

export interface IFinishStepCommand {
    graduationPaperId?: number;
    stepId?: number;
}

export class SupervisorsVm implements ISupervisorsVm {
    list?: SupervisorSm[] | undefined;

    constructor(data?: ISupervisorsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(SupervisorSm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupervisorsVm {
        data = typeof data === 'object' ? data : {};
        let result = new SupervisorsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISupervisorsVm {
    list?: SupervisorSm[] | undefined;
}

export class SupervisorSm implements ISupervisorSm {
    key?: number;
    value?: string | undefined;

    constructor(data?: ISupervisorSm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SupervisorSm {
        data = typeof data === 'object' ? data : {};
        let result = new SupervisorSm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISupervisorSm {
    key?: number;
    value?: string | undefined;
}

export class SendStepToReviewCommand implements ISendStepToReviewCommand {
    graduationPaperId?: number;
    stepId?: number;

    constructor(data?: ISendStepToReviewCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.graduationPaperId = _data["graduationPaperId"];
            this.stepId = _data["stepId"];
        }
    }

    static fromJS(data: any): SendStepToReviewCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendStepToReviewCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["graduationPaperId"] = this.graduationPaperId;
        data["stepId"] = this.stepId;
        return data; 
    }
}

export interface ISendStepToReviewCommand {
    graduationPaperId?: number;
    stepId?: number;
}

export class CreateStudentCommand implements ICreateStudentCommand {
    externalId?: number;
    name?: string | undefined;
    surname?: string | undefined;
    skype?: string | undefined;
    emails?: string[] | undefined;
    phones?: string[] | undefined;
    comments?: string | undefined;
    status?: string | undefined;
    programeId?: number;
    facultyId?: number;
    form?: number;
    language?: string | undefined;
    userId?: number;

    constructor(data?: ICreateStudentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.skype = _data["skype"];
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            this.comments = _data["comments"];
            this.status = _data["status"];
            this.programeId = _data["programeId"];
            this.facultyId = _data["facultyId"];
            this.form = _data["form"];
            this.language = _data["language"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreateStudentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStudentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["skype"] = this.skype;
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        data["comments"] = this.comments;
        data["status"] = this.status;
        data["programeId"] = this.programeId;
        data["facultyId"] = this.facultyId;
        data["form"] = this.form;
        data["language"] = this.language;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface ICreateStudentCommand {
    externalId?: number;
    name?: string | undefined;
    surname?: string | undefined;
    skype?: string | undefined;
    emails?: string[] | undefined;
    phones?: string[] | undefined;
    comments?: string | undefined;
    status?: string | undefined;
    programeId?: number;
    facultyId?: number;
    form?: number;
    language?: string | undefined;
    userId?: number;
}

export class StudentsVm implements IStudentsVm {
    students?: StudentDto[] | undefined;

    constructor(data?: IStudentsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["students"])) {
                this.students = [] as any;
                for (let item of _data["students"])
                    this.students!.push(StudentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentsVm {
        data = typeof data === 'object' ? data : {};
        let result = new StudentsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.students)) {
            data["students"] = [];
            for (let item of this.students)
                data["students"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStudentsVm {
    students?: StudentDto[] | undefined;
}

export class StudentDto implements IStudentDto {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    finishedStepCount?: number;
    totalStepCount?: number;
    faculty?: string | undefined;
    programe?: string | undefined;
    studyLanguage?: string | undefined;
    degree?: string | undefined;

    constructor(data?: IStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.finishedStepCount = _data["finishedStepCount"];
            this.totalStepCount = _data["totalStepCount"];
            this.faculty = _data["faculty"];
            this.programe = _data["programe"];
            this.studyLanguage = _data["studyLanguage"];
            this.degree = _data["degree"];
        }
    }

    static fromJS(data: any): StudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["finishedStepCount"] = this.finishedStepCount;
        data["totalStepCount"] = this.totalStepCount;
        data["faculty"] = this.faculty;
        data["programe"] = this.programe;
        data["studyLanguage"] = this.studyLanguage;
        data["degree"] = this.degree;
        return data; 
    }
}

export interface IStudentDto {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    finishedStepCount?: number;
    totalStepCount?: number;
    faculty?: string | undefined;
    programe?: string | undefined;
    studyLanguage?: string | undefined;
    degree?: string | undefined;
}

export class SupervisorDto implements ISupervisorDto {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    languages?: string[] | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    topics?: string[] | undefined;
    fieldsOfInterest?: string[] | undefined;
    faculty?: string | undefined;
    jobTitle?: string | undefined;

    constructor(data?: ISupervisorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            this.phone = _data["phone"];
            this.email = _data["email"];
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(item);
            }
            if (Array.isArray(_data["fieldsOfInterest"])) {
                this.fieldsOfInterest = [] as any;
                for (let item of _data["fieldsOfInterest"])
                    this.fieldsOfInterest!.push(item);
            }
            this.faculty = _data["faculty"];
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): SupervisorDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupervisorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        data["phone"] = this.phone;
        data["email"] = this.email;
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item);
        }
        if (Array.isArray(this.fieldsOfInterest)) {
            data["fieldsOfInterest"] = [];
            for (let item of this.fieldsOfInterest)
                data["fieldsOfInterest"].push(item);
        }
        data["faculty"] = this.faculty;
        data["jobTitle"] = this.jobTitle;
        return data; 
    }
}

export interface ISupervisorDto {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    languages?: string[] | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    topics?: string[] | undefined;
    fieldsOfInterest?: string[] | undefined;
    faculty?: string | undefined;
    jobTitle?: string | undefined;
}

export class GetSupervisorQuery implements IGetSupervisorQuery {
    id?: number;

    constructor(data?: IGetSupervisorQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetSupervisorQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupervisorQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetSupervisorQuery {
    id?: number;
}

export class CreateSupervisorCommand implements ICreateSupervisorCommand {
    staffId?: number;
    name?: string | undefined;
    surname?: string | undefined;
    facultyId?: number;
    jobPositionId?: number;
    languages?: number[] | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    degree?: string | undefined;
    studentLimit?: number;
    userId?: number;

    constructor(data?: ICreateSupervisorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.facultyId = _data["facultyId"];
            this.jobPositionId = _data["jobPositionId"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.degree = _data["degree"];
            this.studentLimit = _data["studentLimit"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreateSupervisorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSupervisorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["facultyId"] = this.facultyId;
        data["jobPositionId"] = this.jobPositionId;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["degree"] = this.degree;
        data["studentLimit"] = this.studentLimit;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface ICreateSupervisorCommand {
    staffId?: number;
    name?: string | undefined;
    surname?: string | undefined;
    facultyId?: number;
    jobPositionId?: number;
    languages?: number[] | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    degree?: string | undefined;
    studentLimit?: number;
    userId?: number;
}

export class CreateTopicCommand implements ICreateTopicCommand {
    supervisorId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;

    constructor(data?: ICreateTopicCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supervisorId = _data["supervisorId"];
            this.title_RU = _data["title_RU"];
            this.title_EN = _data["title_EN"];
            this.title_LV = _data["title_LV"];
        }
    }

    static fromJS(data: any): CreateTopicCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTopicCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supervisorId"] = this.supervisorId;
        data["title_RU"] = this.title_RU;
        data["title_EN"] = this.title_EN;
        data["title_LV"] = this.title_LV;
        return data; 
    }
}

export interface ICreateTopicCommand {
    supervisorId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
}

export class UpdateTopicCommand implements IUpdateTopicCommand {
    supervisorId?: number;
    topicId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;

    constructor(data?: IUpdateTopicCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supervisorId = _data["supervisorId"];
            this.topicId = _data["topicId"];
            this.title_RU = _data["title_RU"];
            this.title_EN = _data["title_EN"];
            this.title_LV = _data["title_LV"];
        }
    }

    static fromJS(data: any): UpdateTopicCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTopicCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supervisorId"] = this.supervisorId;
        data["topicId"] = this.topicId;
        data["title_RU"] = this.title_RU;
        data["title_EN"] = this.title_EN;
        data["title_LV"] = this.title_LV;
        return data; 
    }
}

export interface IUpdateTopicCommand {
    supervisorId?: number;
    topicId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
}

export class DeleteTopicCommand implements IDeleteTopicCommand {
    supervisorId?: number;
    topicId?: number;

    constructor(data?: IDeleteTopicCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supervisorId = _data["supervisorId"];
            this.topicId = _data["topicId"];
        }
    }

    static fromJS(data: any): DeleteTopicCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTopicCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supervisorId"] = this.supervisorId;
        data["topicId"] = this.topicId;
        return data; 
    }
}

export interface IDeleteTopicCommand {
    supervisorId?: number;
    topicId?: number;
}

export class CreateFieldCommand implements ICreateFieldCommand {
    supervisorId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;

    constructor(data?: ICreateFieldCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supervisorId = _data["supervisorId"];
            this.title_RU = _data["title_RU"];
            this.title_EN = _data["title_EN"];
            this.title_LV = _data["title_LV"];
        }
    }

    static fromJS(data: any): CreateFieldCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFieldCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supervisorId"] = this.supervisorId;
        data["title_RU"] = this.title_RU;
        data["title_EN"] = this.title_EN;
        data["title_LV"] = this.title_LV;
        return data; 
    }
}

export interface ICreateFieldCommand {
    supervisorId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
}

export class UpdateFieldCommand implements IUpdateFieldCommand {
    supervisorId?: number;
    fieldId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;

    constructor(data?: IUpdateFieldCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supervisorId = _data["supervisorId"];
            this.fieldId = _data["fieldId"];
            this.title_RU = _data["title_RU"];
            this.title_EN = _data["title_EN"];
            this.title_LV = _data["title_LV"];
        }
    }

    static fromJS(data: any): UpdateFieldCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFieldCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supervisorId"] = this.supervisorId;
        data["fieldId"] = this.fieldId;
        data["title_RU"] = this.title_RU;
        data["title_EN"] = this.title_EN;
        data["title_LV"] = this.title_LV;
        return data; 
    }
}

export interface IUpdateFieldCommand {
    supervisorId?: number;
    fieldId?: number;
    title_RU?: string | undefined;
    title_EN?: string | undefined;
    title_LV?: string | undefined;
}

export class DeleteFieldCommand implements IDeleteFieldCommand {
    supervisorId?: number;
    fieldId?: number;

    constructor(data?: IDeleteFieldCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supervisorId = _data["supervisorId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static fromJS(data: any): DeleteFieldCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFieldCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supervisorId"] = this.supervisorId;
        data["fieldId"] = this.fieldId;
        return data; 
    }
}

export interface IDeleteFieldCommand {
    supervisorId?: number;
    fieldId?: number;
}

export class LockUserCommand implements ILockUserCommand {
    id?: number;

    constructor(data?: ILockUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LockUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LockUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ILockUserCommand {
    id?: number;
}

export class UnlockUserCommand implements IUnlockUserCommand {
    id?: number;

    constructor(data?: IUnlockUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UnlockUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UnlockUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IUnlockUserCommand {
    id?: number;
}

export class UsersVm implements IUsersVm {
    statuses?: StatusDto[] | undefined;
    roles?: RoleDto[] | undefined;
    users?: UserDto[] | undefined;

    constructor(data?: IUsersVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StatusDto.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleDto.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersVm {
        data = typeof data === 'object' ? data : {};
        let result = new UsersVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUsersVm {
    statuses?: StatusDto[] | undefined;
    roles?: RoleDto[] | undefined;
    users?: UserDto[] | undefined;
}

export class StatusDto implements IStatusDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): StatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStatusDto {
    value?: number;
    name?: string | undefined;
}

export class RoleDto implements IRoleDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRoleDto {
    value?: number;
    name?: string | undefined;
}

export class UserDto implements IUserDto {
    username?: string | undefined;
    status?: number;
    role?: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.status = _data["status"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["status"] = this.status;
        data["role"] = this.role;
        return data; 
    }
}

export interface IUserDto {
    username?: string | undefined;
    status?: number;
    role?: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}